%*****************************************
\chapter{Anforderungsanalyse}\label{ch:php7}
%*****************************************
Dieser Abschnitt soll beleuchten, welche Bedingungen PHP in Version 7 gegenüber Version 5 an lauffähige Software stellt. Zudem werden die Änderungen in den Kontext der
zeitlichen Entwicklung gestellt, um Aussagen über Gründe dieser zu treffen.

\section{Abwärtsinkompatible Änderungen}
Änderungen in dieser Kategorie führen in älteren Versionen zu Fehlern oder unerwartetem Verhalten und sind in dieser Umgebung somit nicht lauffähig. Durch diese wird ein 
Wechsel der Umgebung zwingend vorrausgesetzt.

\section{Veraltete Funktionen}
Als veraltet markierte Funktionen sind in der neuen Umgebung zwar noch unterstützt, sollten aber nach Möglichkeit nicht mehr eingesetzt und schnellstmöglich durch geeignete 
Funktionen ersetzt werden, da sie möglicherweise in zukünftigen Versionen entfernt oder verändert werden. Werden diese Funktionen trotzdem eingesetzt, wird eine Warnung 
ausgegeben, die Programmierer darauf hinweisen soll, dass die Verwendung der Funktion möglicherweise gefährlich sein kann. Die Lauffähigkeit des Programms wird bis zur 
abschließenden Entfernung der Funktion jedoch nicht beeinflusst. \cite{oracle_how_2004}
    \subsection{Implizite Benennung von Konstruktoren}
    Mit der Einführung der objektorientierten Programmierung in PHP 4 wurde festgelegt, dass Funktionen mit dem selben Namen wie die umschließende Klasse implizit als 
    Konstruktor der Klasse erkannt werden. Ein Beispiel zur Implementierung eines Konstruktors nach diesem Prinzip ist in Listing~\ref{lst:php4construct} dargestellt.
    PHP 7 unterstützt diese Notation zwar noch, allerdings wird die, in PHP 5 eingeführte, explizite Benennung mit dem Schlüsselwort \textit{\_\_construct} (siehe 
    Listing~\ref{lst:php5construct}) bevorzugt. Hierdurch soll die Verwirrung darum, wann eine Funktion einen Konstruktor darstellt aufgehoben werden. \cite{morrison_php:_2014}
    \begin{lstlisting}[language=php, caption={Beispiel eines impliziten Konstruktors}, label={lst:php4construct}]
        <?php
        class foo {
            function foo($a) {
                echo("Created instance of class 'foo'");
            }
        }
        ?>
    \end{lstlisting}

    \begin{lstlisting}[language=php, caption={Beispiel eines expliziten Konstruktors}, label={lst:php5construct}]
        <?php
        class foo {
            function __construct($a) {
                echo("Created instance of class 'foo'");
            }
        }
        ?>
    \end{lstlisting}
    
    \subsection{Statische Aufrufe nicht-statischer Funktionen}
    Mit dem Schlüsselwort \textit{static} versehene Funktionen einer Klasse erlauben das Benutzen der Funktion, ohne die 
    Instantiierung der Klasse selber. Damit steht die entsprechende Funktion nicht im Kontext eines Objekts, sondern 
    im Kontext der entsprechenden Klasse. Im Gegensatz zu anderen objektorientierten Programmiersprachen (bspw. Java) war es 
    in PHP bisher möglich, auch nicht-statische Methoden ohne eine Instantiierung zu verwenden. Diese Möglichkeit wurde mit
    PHP 7 für veraltet erklärt und sollte nicht mehr genutzt werden. Dadurch werden Programmierfehler verhindert, da der Kontext, in dem eine Funktion ausgeführt wird nun
    Eindeutig ist. Das Beispiel~\ref{lst:php7static} wird eine Warnung ausgeben, dass eine nicht-statische Methode statisch aufgerufen wird.
    \begin{lstlisting}[language=php, caption={Beispiel eines statischen Aufrufs einer nicht-satischen Funktion in PHP 7}, label={lst:php7static}]
        <?php
        class foo {
            function bar() {
                echo("'bar' is not a static function");
            }
        }

        foo::bar();
        ?>
    \end{lstlisting}

\section{Geänderte Funktionen}
In diese Gruppe fallen Funktionen, deren Benutzung und/oder Verhalten geändert wurden, allerdings nicht vollständig veraltet sind. Dies bedeutet zum Beipiel, dass 
einzelne Funktionsparameter entfernt wurden oder andere Datentypen zurückgegeben werden.
    \subsection{preg\_replace} \label{preg_replace}
    Die Funktion \textit{preg\_replace()} ersetzt Teile einer Zeichenkette nach einem, als regulärem Ausdruck angegebenen, Muster. Mit \textit{\acs{PCRE}-Modifikatoren} 
    kann die Verhaltensweise des regulären Ausdrucks gesteuert werden. In \acs{PHP} 7 wurde der Modifikator \textit{/e} entfernt, mit dem die Zeichenkette durch das Ergebnis
    einer Funktion ersetzt wird. Ein Beipiel ist die Umwandlung aller kleingeschriebenen Zeichen eines Strings in Großbuchstaben, dargestellt in Listing~\ref{lst:php5preg_rep}. Die Verwendung
    des Modifikators wird aufgrund der Maskierungsregeln für bestimmte Zeichen als sehr kompliziert beschrieben. Gleichzeitig stellt die einfache Art der Evaluierung
    des Ergebnisses keine Schutzmechanismen zur Verfügung, wodurch Sicherheitslücken entstehen können, sobald es einem Angreifer gelingt, ausfühbaren Code in diese
    Funktion einzuschleusen. 

    \begin{lstlisting}[language=php, caption={Beispiel der Nutzung von preg\_replace mit dem Modifikator /e}, label={lst:php5preg_rep}]
        <?php
        $uppercase = preg_replace(
            "/([a-z]*)/e",
            "strtoupper($1)",
            $mixedCase
        );
        ?>
    \end{lstlisting}

    \subsection{setlocale}
    Die Funktion \textit{setlocale()} dient dazu, regionale Eigenheiten abzubilden. Dazu gehören zum Beispiel unterschiedliche Datumsformate oder die Formatierung von 
    Zahlen (bspw. Trennzeichen für Dezimalzahlen). Für die Einstellung einer Region können Kategorien angegeben werden, auf die sich die Änderung auswirken soll. 
    Ab Version 7 ist es nicht mehr möglich, die Kategorie als Zeichenkette anzugeben. Für diese Änderung ist kein Grund angegeben, allerdings liegt die Vermutung
    nahe, dass sich dadurch die Prüfung der Kategorie innerhalb der Funktion vereinfachen lässt, da \acs{PHP} verschiedene benannte Konstanten zur Anwendung zur Verfügung 
    stellt. Dies lässt sich auch durch die Historie der betreffenden Funktion im Quellcode belegen, durch die ersichtlich wird, dass ein großer Teil der Überprüfung
    der Funktionsparameter entfernt wurde. \cite{nikic_remove_2014}

\section{Neue Funktionen}
    \subsection{Anonyme Klassen}
    Mit dem Hinzufügen von anonymen Klassen implementiert \acs{PHP} ein Konzept, das bereits aus anderen Objektorientierten Sprachen, beispielsweise Java 
    \cite{oracle_anonymous_nodate}, bekannt ist. Diese können benutzt werden, um gleichzeitig mit der Definition eine einmalig genutzte Klasse zu instanziieren, ohne eigens 
    dafür eine neue lokale Klasse erstellen zu müssen., wie in Listing~\ref{lst:php7anon_class} dargestellt wird.

    \begin{lstlisting}[language=php, caption={Beispiel der Nutzung anonymer Klassen}, label={lst:php7anon_class}]
        <?php
        $foo = new class {
            public function bar() {
                echo "Hello World";
            }
        };

        $foo->bar();
        ?>
    \end{lstlisting}

    \subsection{preg\_replace\_callback\_array()}
    Ähnlich wie die im Abschnitt \ref{preg_replace} beschriebene Funktion \textit{preg\_replace()} mit dem Modifikator \textit{/e}, ersetzt 
    \textit{preg\_replace\_callback\_array()} Zeichenketten anhand eines Musters und einer Ersetzungsfuntion. Im eingeführten \textit{preg\_replace\_callback\_array()} 
    kann nun ein assiozatives Array angegeben werden, das mehrere Muster und ihre entsprechenden Callback-Funktionen enthält. Durch die Nutzung verschiedener 
    Ersetzungsfunktionen kann auf die Nutzung einer einzelnen, stark verzweigten Ersetzungsfuntion verzichtet werden. Dadurch wird entsprechender Quellcode lesbarer 
    und besser wartbar (vgl. \cite[S. 34f]{martin_clean_2012}).

    \subsection{Typdeklaration für Rückgabewerte} %TODO: Referenz PHP Typen
    Als schwach typisierte Sprache bot \acs{PHP} bisher keine Möglichkeit der Deklaration von Typen für Rückgabewerte von Funktionen. Dies kann nun durch Angabe des
    Typs zwischen Funktionsdeklaration und dem Code der Funktion geschehen. Dadurch sollen unter anderem ungewollte Rückgabewerte verhindert werden, als auch die 
    automatisierte Dokumentation von Funktionen vereinfacht werden. \cite{morrison_php:_2014-1}

\section{Entfernte Erweiterungen}
    \subsection{mysql}
    Die seit \acs{PHP} 5 als veraltet erklärte Erweiterung \textit{mysql} wird nicht mehr unterstützt. Dies wird mit Sicherheitsrisiken begründet. So unterstützt
    \textit{mysql} beispielsweise keine \textbf{Prepared Statements}, welche einen wirksamen Schutz gegen \textbf{SQL Injections} bieten. \cite{oracle_mysql_nodate}
    Zudem stehen mit \textit{mysqli} und \textit{PDO} aktuellere Erweiterungen zur Verfügung.
    
    \subsection{ereg}

