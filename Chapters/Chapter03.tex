%************************************************
\chapter{Untersuchung geeigneter Mittel}\label{ch:tools} 
%************************************************

Wie in Kapitel \ref{ch:php7} gezeigt, sind die Veränderungen zwischen \acs{PHP} 5 und \acs{PHP} 7 nicht nur sehr umfangreich, sondern erfordern auch große Eingriffe 
in den betroffenen Quellcode. \textbf{ISO/IEC 14764} sieht vor, die Migration zu definieren

\section{Erkennung des zu ändernden Codes}
    Um alten Code migrieren zu können, müssen alle Stellen gefunden werden, die in ihrer ursprünglichen Form in der neuen Umgebung nicht lauffähig sind. Dafür relevante
    Beispiele sind in Kapitel \ref{ch:php7} gelistet, die gesamte Liste kann der Dokumentation entnommen werden. Die Erkennung kann je nach Umfang des Quellcodes
    und der verwendeten Funktionen entweder manuell oder automatisiert durchgeführt werden. Für beide Arten werden im folgenden Beispiele genannt und die jeweiligen
    Vor- und Nachteile diskutiert.
    \subsection{Manuelle Erkennung}
        Eine manuelle Erkennung des Codes bietet sich vor allem bei kleinen Softwareprojekten an, bei denen ein vollumfänglicher Überblick über den eingesetzten Code
        besteht. Hier kann durch die in typischen Editoren und Entwicklungsumgebungen integrierte Suche genutzt werden um alle Vorkommen von nicht lauffähigen
        Funktionen zu finden und diese anschließend einem Refactoring zu unterziehen. Besonders einfach gestaltet sich diese Methode bei entfernten Funktionen,
        beispielsweise die der Erweiterung \textit{ereg}\ref{ereg}. Diese kann der Entwickler in der Dokumentation nachschlagen und den Code auf etwaige Vorkommen prüfen.
        Schwierig wird die manuelle Erkennung bei Änderungen wie der Einhaltung des Standards in Switch-Anweisungen\ref{switch}. Hier ist eine Suche nur über umfangreiche
        Suchmuster (Reguläre Ausdrücke) möglich, die meist nicht trivial zu erstellen sind und viele Einzelfälle (z.B. verschachtelte Switch-Anweisungen) abdecken müssen.
        In diesen Fällen ist durch die manuelle Suche höchstens eine Eingrenzung des Problems möglich.
    \subsection{Automatisierte Erkennung}
        Da die zuvor besprochene manuelle Erkennung betroffenen Codes nur für einzelne Fälle oder kleine Projekte in Frage kommt, bietet sich als alternative die 
        automatiche Erkennung an, mit dem Ziel, dem Entwickler einen vollumfänglichen Überblick der zu überarbeitenden Stellen im Code zu liefern. Im vorliegenden Fall
        wurde das Tool \textit{\ac{php7mar}}\footnote{Alexia. php7mar. URL: \url{https://github.com/Alexia/php7mar}} des Entwicklers \textit{Alexia} genutzt.
        \textit{\ac{php7mar}} erkennt mithilfe von \textbf{Regulären Audrücken}, \textbf{String-Matching} und \textbf{Lexikalischer Analyse} kritischen Code in 
        Projekten und generiert daraus einen Bericht, bestehend aus Zeilenangaben, gefundenen Problemen und Lösungshinweisen. Ein Beispiel eines solchen Berichts findet
        sich in Listing\ref{lst:php7mar}. In der Datei \textit{GMCSS.php} werden drei Fehlerklassen gefunden: Erstens mehrere Fälle der Nutzung der veralteten Definition von
        Konstruktoren, zweitens einige Vorkommen der Entfernten Erweiterung \textit{mysql}, sowie drittens ein indirekter Variablenzugriff, dessen Aussage unter PHP 7
        möglicherweise eine andere ist (vgl. Kapitel~\ref{indirectVar}). Insbesondere der erste Fall zeigt die Überlegenheit eines Analysetools, da solche Fehler nur
        schwer mit einer trivialen Suche zu finden sind.

        \begin{lstlisting}[caption={Beispiel eines generierten Berichts mit \textit{\ac{php7mar}}}, label={lst:php7mar}]
            #### C:\Users\Nutzer\Documents\GitHub\gambio_tickets75\StyleEdit\classes\GMCSS.php
            * oldClassConstructors
            * Line 55:  `function GMCSS($p_css_file, $p_type='archive')`
            * Line 384: `function GMCSSImport($p_css_file = false, $p_import_mode = '')`
            * Line 791: `function GMCSSExport($p_css_file)`
            * Line 912: `function GMCSSUpload($p_files, $p_type)`
            * Line 982: `function GMCSSArchive()`
            * deprecatedFunctions
            * Line 302: `$t_css_query = mysql_query("`
            * Line 311: `if((int)mysql_num_rows($t_css_query) > 0)`
            * Line 313: `$t_row_styles = mysql_fetch_array($t_css_query, MYSQL_ASSOC);`
            * Line 316: `$t_css_query = mysql_query("`
            * Line 325: `if((int)mysql_num_rows($t_css_query) > 0)`
            * variableInterpolation
            * Line 359: `global $$shippingModule; //notice $$`
        \end{lstlisting}

\section{Refactoring}
    Refactoring beschreibt die Technik, bestehenden Code in seiner Struktur so zu verändern, dass dieser änderbar bleibt und wichtige Bestandteile leicht indentifizierbar 
    bleiben, ohne jedoch den eigentlichen Sinn des Programms zu verändern. \cite{fowler_refactoring_1999} Bei der Migration von Software muss dem Refactoring ein hoher Stellenwert zugemessen werden, 
    da große Bestandteile des Codes ausgetauscht und verändert werden, was nach Lehman \cite[S. 1060-1076]{lehman_programs_1980} zur Degeneration von Software führt.
    Die Schwierigkeit des Refactorings liegt häufig im zeitaufwändigen Verstehen des vorliegenden Codes. Diese Zeit muss jedoch für die Migration der Software ohnehin 
    aufgewendet werden, womit sich ein Refactoring hier durchaus anbietet.
    Die Ziele des Refatorings können durch verschiedenste Techniken erreicht werden, beispielsweise die Zerlegung von Funktionen in kleinere, bessere verständliche 
    Funktionen oder die Auslagerung von immer wieder genutztem Code in eine eigene Funktion.
    \subsection{Extrahieren}
        Bei der Extraktion von Funktionen sollen häufig genutzte Programmteile in eine eigene, wiederverwendbare Funktion ausgelagert werden. Dazu wird die neue Funktion
        angelegt, 
    \subsection{Zerlegung von Funktionen}
    \subsection{Unit-Tests}

\section{Lauffähigkeit historischen Codes}
    Der Standard ISO/IEC 14764 sieht auch nach der erfolgten Migration eine Unterstützung der alten Umgebung vor. Dies ist natürlich vor allem bei Produkten sinnvoll, 
    die von Dritten eingesetzt werden, die dadurch vor nicht erwartetem Verhalten der Software geschützt werden. Allerdings ist eine Unterstützung der alten Umgebung 
    auch bei unternehmenseigener Software sinnvoll. Beispielsweise lassen sich Fehler im Programm zurückverfolgen, Änderungen nachvollziehen und sichergestellt werden,
    dass im Falle eines Fehlers bei der Migration eine lauffähige Version zur Verfügung steht. Daraus ergeben sich jedoch einige Probleme. So muss nicht nur der Quellcode 
    von alten Versionen eines Programms zur Verfügung stehen, sondern auch die verschiedenen Umgebungen um die Software ausführen zu können.
    \subsection{Versionsverwaltung}
        Grundlage für die Unterstützung alter Versionen einer Software ist, dass diese Versionen in ihrem ausgelieferten Zustand vorhanden sind und Änderungen, die seitdem
        vorgenommen wurden protokolliert und nachvollziehbar sind. Ein einfacher Ansatz dazu wäre beispielsweise die Ablage des Programmcodes in einem eindeutig benannten 
        Ordner, nachdem eine Änderung durchgeführt wurde, sowie der Einsatz eines Programms wie beispielsweise \textbf{Diff} \footnote{GNU Diffutils, URL: \url{http://www.gnu.org/software/diffutils/}} 
        zur Kenntlichmachung von Änderungen zwischen zwei Dateien. Diese Vorgehensweise kann zwar für kleinere Projekte genügen, ist jedoch für große Projekte mit mehreren 
        hundert einzelnen Dateien und beliebig vielen bearbeitenden Personen nicht geeignet. Dieses Problem kann durch den Einsatz einer dedizierten Software zur 
        Versionsverwaltung gelöst werden. Diese Software beinhaltet den gesamten Quellcode des Projekts in einem \textbf{Repository}, stellt diesen den Nutzern bereit 
        und protokolliert jede Änderung, sogenannte \textbf{Commits}. Durch diese Protokollierung kann der Quellcode in jeden beliebigen früheren Zustand zurückversetzt 
        werden, und somit auch weiter gewartet werden. Bekannte Programme zur Versionsverwaltung mit den genannten Funktionen sind zum Beispiel 
        \textit{Git}\footnote{Git, \url{https://git-scm.com/}} oder \textit{Mercurial}\footnote{Mercurial, URL: \url{https://www.mercurial-scm.org/}}
    \subsection{Ausführungsumgebung}
        Zu jeder historischen Version der Software muss die passende Ausführungsumgebung zur Verfügung stehen. Dies betrifft nicht nur PHP, sondern beispielsweise auch 
        Python mit der immer noch andauernden flächendeckenden Umstellung von Version 2 auf 3. 
        \subsubsection{Lokale Ausführungsumgebung}
        
        \subsubsection{Continuous Integration mittels Containern}


